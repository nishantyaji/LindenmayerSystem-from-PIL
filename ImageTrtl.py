from PIL import Image
import numpy, operator, math

class ImageTrtl:
    """
    To emulate Turtle through Python Image

    Fractals and designs generated by Turtle cannot be saved directly.
    To get around this problem, I am coding up a very rudimentary 
    Python (PIL) based implementation of Turtle

    Also Lindenmayer system can be plotted with this class.
    In a manner akin to turle one can generate and save fractals 
    Please look into the "fractals" folder

    """
    def __init__(self):
        self.bgcolor = (0, 0, 0)
        self.fgcolor = (0, 255, 0)
        #import turtle
        #turtle.Screen().screensize()
        self.width = 800
        self.height = 600
        self.img = Image.new("RGB", (self.width, self.height), self.bgcolor)
        self.current_pos = (self.width/2, self.height/2)
        self.heading = 0

    def __plot(self, source, destn, x_gradient=0.01):
        min_x, max_x = sorted([source, destn], key=operator.itemgetter(0))
        if min_x[0] != max_x[0]:
            x_s = [x for x in numpy.arange(min_x[0], max_x[0]+x_gradient, x_gradient)]
            multiple = (destn[1]-source[1])/(destn[0]-source[0])
            y_s = [source[1]+(x-source[0])*multiple for x in x_s]
        else: #the line is parallel to y axis
            min_y, max_y = sorted([min_x, max_x], key=operator.itemgetter(1))
            y_s = [y for y in numpy.arange(min_y[1], max_y[1], x_gradient)]
            x_s = [min_y[0]]*len(y_s)
        for x, y in zip(x_s, y_s):
            x, y = int(x), int(y)
            self.img.putpixel((x,y), self.fgcolor)

    def keep_in_bounds(self, coordinates):
        x, y = coordinates
        x = min(max(0,x), self.width-1)
        y = min(max(0,y), self.height-1)
        return x,y

    def forward(self, distance):
        if self.heading == 0:
            destn = self.current_pos[0]+distance, self.current_pos[1]
        elif self.heading == 180:
            destn = self.current_pos[0]-distance, self.current_pos[1]
        elif self.heading == 90:
            destn = self.current_pos[0], self.current_pos[1]-distance
        elif self.heading == 270:
            destn = self.current_pos[0], self.current_pos[1]+distance
        else:
            x_diff = distance * math.cos(math.radians(self.heading))
            y_diff = distance * math.sin(math.radians(self.heading))
            destn = self.current_pos[0]+x_diff, self.current_pos[1]+y_diff

        destn = self.keep_in_bounds(destn)
        self.__plot(self.current_pos, destn)
        self.current_pos = destn

    def backward(self, distance):
        self.forward(-distance)

    def left(self, degrees):
        self.heading = (self.heading+degrees)%360

    def right(self, degrees):
        self.heading = (self.heading-degrees)%360

    def goto(self, x, y):
        self.__plot(self.current_pos, (x,y))
        self.current_pos = (x, y)

    def show(self):
        self.img.show()

    def done(self):
        self.show()

if __name__ == '__main__':
    t = ImageTrtl()
    t.current_pos = 200, 150
    t.forward(20)
    t.left(90)
    t.forward(20)
    t.left(90)
    t.forward(20)
    t.right(90)
    t.forward(20)
    t.show()